# Javascript模块全揽

## 从脚本加载开始

一切从Javascript的加载开始，自有Javascript依赖，第一个加载模块的方案就是使用HTML标签，也就是`<script>`标签。也就是说，Javascript本身根本就没有模块和加载的定义，它是利用HTML来完成本该自己做的工作。

这是初学者遇到的第一个令人困惑的问题。这样的语言，根本就是一个玩具！也许有些尴尬，但是现实就是如此。并且如此的加载方案，在稍微大点的工程中，会遇到几个违反常识的问题：

1. 全局命名污染。就是说每一个被加载的模块都会引入新的全局变量，他们会污染全局空间，而且必须小心命名，避免名字的冲突
2. 依赖关系单一。此种加载方式，必须按照依赖关系排序，在依赖链最底层的，需要最先加载
3. 加载和执行效率难以细颗粒度的调优。以为依赖关系，此后一个个的按依赖次序加载和执行。虽然加载往往是可以并行的，但是执行时串行的

还是从一个案例开始。这个案例，不会做任何有意义的工作，也不会做什么功能演示，而只是验证古典的Javascript加载的能力和限定，验证这些问题的存在，进而找到解决问题的方法。

假设我们现在有一个主程序，它在index.html内，一个模块dep1，一个模块dep2，依赖关系是index.html依赖dep1，dep1依赖dep2。代码都不复杂，就是直接列表如下：

文件index.html

	// index.html
	<script src="dep2.js"></script>
	<script src="dep1.js"></script>
	<script type="text/javascript">
		console.log(dep1())
	</script>

文件dep1.js

	var v1 = "dep1"
	function dep1(){
		return v1+"-"+dep2()
	}

文件dep2.js

	var v2 = "dep2"
	function dep2(){
		return v2
	}


当使用浏览器加载index.html文件时，如我所愿，它会随后加载dep2,dep1,并调用函数dep1，后者调用dep2，然后在控制台输出：

	dep1+dep2

功能是有效的，依赖关系是是对的，输出也是如期望的。但是它也带来了额外的问题：

1. 全局变量污染。在本案例中，可以在console内验证，发现变量v1，v2，函数dep1，dep2都是全局变量。但是由于script的加载机制，以及当前采用的Javascript函数和变量的定义不是局部化的，导致了这样的问题。
2. 依赖关系并不严密。事实上，dep2内的引入变量和函数，只有dep1看得到即可，无需导入到全局变量内。
3. 加载和执行效率难以细颗粒度的调优。本例内，dep1依赖dep2，它们被并行转入，但是执行必须是串行的，首先执行dep2，然后执行dep1，在此案例中，这样做是合适的，但是有不少代码模块之间并不存在依赖关系，它们完全可能并发装入并发执行，但是使用script装入是不能如此的，它会按照标签的次序一个个的执行。如果有比较好的指定依赖关系的方法就好了。

讨论到此，我感觉我在重复先辈们的话，实际上1960年代，第一届软件工程会议，就提出了模块化编程的概念，并且在之后多年一直努力的批评全局变量和Goto语句了。有时候，你会发现，这样看起来非常不济的语言，却可以在现实的项目中如鱼得水，发展的非常的好。而软件工程思想指导下的一些名流语言却早早夭折。这是另外一个有趣的话题了，或许以后有机会谈到。

## 后端的借鉴

后端Nodejs干净利索的解决了此问题。做法就是对每一个装入的模块都注入一个require函数和一个exports对象。其中require函数可以被模块用来引入其他模块，而exports对象则被用来引出当前模块的功能接口。还是以前文提到的作为案例，做法就是：

文件index.js

	// index.js
	var d = require('./dep1')
	console.log(d.dep1())

文件dep1.js

	var d = require('./dep2')
	var v1 = "dep1"
	function dep1(){
		return v1+"-"+d.dep2()
	}
	exports.dep1 = dep1

文件dep2.js

	var v2 = "dep2"
	function dep2(){
		return v2
	}
	exports.dep2 = dep2

这里有一点变化，就是在nodejs内使用index.js代替了index.html。可以看到：
1. Nodejs提供了很好的局部化定义变量和函数的能力，如果使用exports声明引出，其他模块看不到本模块的定义。比如v2变量没有声明引出，当然实际上在本案例内本来也不必引出，那么在dep1内并不会看到v2变量。类似的v1也不会出现在index.js内。
2. Nodejs提供了更加细粒度的依赖关系。index.js依赖dep1，但是并不依赖于dep2，那么index.js就只要引入dep1，而不必同时引入dep2。这样的依赖关系，更加符合实际工程代码的需求，而不是一股脑的、不分层次的引入全部需要用到的代码。

